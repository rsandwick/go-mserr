// +build ignore

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"golang.org/x/net/html"
)

// HRESULT, NTSTATUS, and Win32 values scraped from openspecs documentation.
//
// The winerror table has an errant <br> in one of its rows, which has been
// fixed by hand rather than add tolerant-but-complicated logic below.
//
// hresult : https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/705fb797-2175-4a90-b5a3-3918024b10b8
// ntstatus: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55
// winerror: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/18d8fbe8-a967-4f1c-ae50-99ca8e491d2d

type mserr struct{ Name, Code, Descr string }
type scrape struct {
	Name     string
	Type     string
	Long     int
	DupeLong int
	Errs     []mserr
	Dupe     []mserr
}

var tplConsts = template.Must(template.New("mserrConst").Parse(
	`// Code generated by "go run ./ms-erref-generate.go"; DO NOT EDIT.
package {{.Name}}

{{with $s := . -}}

const (
{{- with $x := (printf "%%-%ds" .Long) -}}
{{- range $s.Errs}}
	{{printf $x .Name}} {{$s.Type}} = {{.Code}}
{{- end -}}
{{- end -}}
{{- if .DupeLong}}
{{end -}}
{{- with $x := (printf "%%-%ds" .DupeLong) -}}
{{- range $s.Dupe}}
	{{printf $x .Name}} {{$s.Type}} = {{.Code}}
{{- else -}}
{{- end -}}
{{- end}}
)

func (x {{.Type}}) Error() string {
	switch x {
	{{- range .Errs}}
	case {{.Name}}:
		return ` + "`" + `{{.Descr}}` + "`" + `
	{{- end}}
	default:
		return ` + "`" + `Unknown {{.Type}}` + "`" + `
	}
}

func (x {{.Type}}) String() string {
	switch x {
	{{- range .Errs}}
	case {{.Name}}:
		return "{{.Name}}"
	{{- end}}
	default:
		return "{{.Type}}(" + string(uint32(x)) + ")"
	}
}
{{- end}}
`))

func main() {
	for _, s := range []scrape{
		scrape{Name: "hresult", Type: "HResult"},
		scrape{Name: "ntstatus", Type: "NTStatus"},
		scrape{Name: "winerror", Type: "Win32Error"},
	} {
		in, err := os.Open(filepath.Join(s.Name, s.Name + "_values.html"))
		if err != nil {
			panic(err)
		}
		root, err := html.Parse(in)
		if err != nil {
			panic(err)
		}
		in.Close()
		main := findTag(root, "main")
		if main == nil {
			panic(fmt.Errorf("couldn't find <main>"))
		}
		tbody := findTag(main, "tbody")
		if tbody == nil {
			panic(fmt.Errorf("couldn't find <tbody>"))
		}
		s.Errs = make([]mserr, 0)
		s.Dupe = make([]mserr, 0)
		unique := make(map[uint32]struct{})
		for tr := tbody.FirstChild; tr != nil; tr = tr.NextSibling {
			x := mserrFromRow(tr)
			if len(x.Name) > s.Long {
				s.Long = len(x.Name)
			}
			v, err := strconv.ParseUint(x.Code, 0, 32)
			if err != nil {
				panic(err)
			}
			if _, ok := unique[uint32(v)]; ok {
				if len(x.Name) > s.DupeLong {
					s.DupeLong = len(x.Name)
				}
				s.Dupe = append(s.Dupe, x)
			} else {
				s.Errs = append(s.Errs, x)
				unique[uint32(v)] = struct{}{}
			}
		}
		out, _ := os.Create(filepath.Join(s.Name, s.Name + "_values.go"))
		if err != nil {
			panic(err)
		}
		if err := tplConsts.Execute(out, s); err != nil {
			fmt.Printf("%+v\n", err)
		}
	}
}

func findTag(n *html.Node, tag string) *html.Node {
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode {
			if c.Data == tag {
				return c
			}
			if n := findTag(c, tag); n != nil {
				return n
			}
		}
	}
	return nil
}

func nextSiblingTag(n *html.Node, tag string) *html.Node {
	for c := n.NextSibling; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode && c.Data == tag {
			return c
		}
	}
	return nil
}

func mserrFromRow(tr *html.Node) (x mserr) {
	// hardcoded, but simple -- if the table changes, we'll have to refactor
	// this scraper anyway, so no point spending a lotta time on "elegance"
	td1 := findTag(tr, "td")
	p1 := findTag(td1, "p")
	x.Code = strings.TrimSpace(p1.FirstChild.Data)
	p2 := nextSiblingTag(p1, "p")
	x.Name = strings.TrimSpace(p2.FirstChild.Data)
	td2 := nextSiblingTag(td1, "td")
	p3 := findTag(td2, "p")
	m := strings.TrimSpace(p3.FirstChild.Data)
	x.Descr = strings.Join(strings.Fields(m), " ")
	return
}
